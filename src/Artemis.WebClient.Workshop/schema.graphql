# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
    "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
    weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize(
    "The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field."
    assumedSize: Int,
    "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error."
    requireOneSlicingArgument: Boolean! = true,
    "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields."
    sizedFields: [String!],
    "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query."
    slicingArgumentDefaultValue: Int,
    "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments."
    slicingArguments: [String!]
) on FIELD_DEFINITION

type Category {
    entryType: EntryType
    icon: String!
    id: Long!
    name: String!
}

"Information about the offset pagination."
type CollectionSegmentInfo {
    "Indicates whether more items exist following the set defined by the clients arguments."
    hasNextPage: Boolean!
    "Indicates whether more items exist prior the set defined by the clients arguments."
    hasPreviousPage: Boolean!
}

type DefaultEntryInfo {
    entryId: Long!
    isDeviceProvider: Boolean!
    isEssential: Boolean!
}

"A segment of a collection."
type EntriesCollectionSegment {
    "A flattened list of the items."
    items: [Entry!]
    "Information to aid in pagination."
    pageInfo: CollectionSegmentInfo!
    totalCount: Int!
}

"A connection to a list of items."
type EntriesV2Connection {
    "A list of edges."
    edges: [EntriesV2Edge!]
    "A flattened list of the nodes."
    nodes: [Entry!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Identifies the total count of items in the connection."
    totalCount: Int!
}

"An edge in a connection."
type EntriesV2Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Entry!
}

type Entry {
    author: String!
    authorId: UUID!
    categories: [Category!]!
    createdAt: DateTime!
    defaultEntryInfo: DefaultEntryInfo
    dependantReleases: [Release!]!
    description: String!
    downloads: Long!
    entryType: EntryType!
    icon: Image
    iconId: UUID
    id: Long!
    images: [Image!]!
    isOfficial: Boolean!
    latestRelease: Release
    latestReleaseId: Long
    layoutInfo: [LayoutInfo!]!
    name: String!
    pluginInfo: PluginInfo
    releases: [Release!]!
    summary: String!
    tags: [Tag!]!
}

type Image {
    description: String
    entry: Entry
    entryId: Long
    height: Int!
    id: UUID!
    mimeType: String!
    name: String!
    size: Long!
    width: Int!
}

type LayoutInfo {
    deviceProvider: UUID!
    deviceType: RGBDeviceType!
    entry: Entry!
    entryId: Long!
    id: Long!
    logicalLayout: String
    model: String!
    physicalLayout: KeyboardLayoutType
    vendor: String!
}

type Mutation {
    addEntry(input: CreateEntryInput!): Entry
    addLayoutInfo(input: CreateLayoutInfoInput!): LayoutInfo
    removeEntry(id: Long!): Entry
    removeLayoutInfo(id: Long!): LayoutInfo!
    removeRelease(id: Long!): Release!
    setLayoutInfo(input: SetLayoutInfoInput!): [LayoutInfo!]!
    updateEntry(input: UpdateEntryInput!): Entry
    updateEntryImage(input: UpdateEntryImageInput!): Image
    updateRelease(input: UpdateReleaseInput!): Release
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "Indicates whether more edges exist following the set defined by the clients arguments."
    hasNextPage: Boolean!
    "Indicates whether more edges exist prior the set defined by the clients arguments."
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PluginInfo {
    entry: Entry!
    entryId: Long!
    helpPage: String
    pluginGuid: UUID!
    repository: String
    requiresAdmin: Boolean!
    supportsLinux: Boolean!
    supportsOSX: Boolean!
    supportsWindows: Boolean!
    website: String
}

"A segment of a collection."
type PluginInfosCollectionSegment {
    "A flattened list of the items."
    items: [PluginInfo!]
    "Information to aid in pagination."
    pageInfo: CollectionSegmentInfo!
    totalCount: Int!
}

type Query {
    categories(order: [CategorySortInput!], where: CategoryFilterInput): [Category!]!
    entries(includeDefaults: Boolean, order: [EntrySortInput!], search: String, skip: Int, take: Int, where: EntryFilterInput): EntriesCollectionSegment
    entriesV2(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        includeDefaults: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [EntrySortInput!],
        search: String,
        where: EntryFilterInput
    ): EntriesV2Connection
    entry(id: Long!): Entry
    pluginInfo(pluginGuid: UUID!): PluginInfo
    pluginInfos(order: [PluginInfoSortInput!], skip: Int, take: Int, where: PluginInfoFilterInput): PluginInfosCollectionSegment
    popularEntries(where: EntryFilterInput): [Entry!]!
    release(id: Long!): Release
    searchEntries(input: String!, order: [EntrySortInput!], type: EntryType, where: EntryFilterInput): [Entry!]!
    searchKeyboardLayout(deviceProvider: UUID!, logicalLayout: String, model: String!, physicalLayout: KeyboardLayoutType!, vendor: String!): LayoutInfo
    searchLayout(deviceProvider: UUID!, deviceType: RGBDeviceType!, model: String!, vendor: String!): LayoutInfo
    submittedEntries(order: [EntrySortInput!], where: EntryFilterInput): [Entry!]!
}

type Release {
    changelog: String
    createdAt: DateTime!
    dependencies: [Entry!]!
    downloadSize: Long!
    downloads: Long!
    entry: Entry!
    entryId: Long!
    id: Long!
    md5Hash: String
    minimumVersion: String
    version: String!
}

type Tag {
    id: Long!
    name: String!
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
    "After the resolver was executed."
    AFTER_RESOLVER
    "Before the resolver was executed."
    BEFORE_RESOLVER
    "The policy is applied in the validation step before the execution."
    VALIDATION
}

enum EntryType {
    LAYOUT
    PLUGIN
    PROFILE
}

enum KeyboardLayoutType {
    ABNT
    ANSI
    ISO
    JIS
    KS
    UNKNOWN
}

enum RGBDeviceType {
    ALL
    COOLER
    DRAM
    FAN
    GAME_CONTROLLER
    GRAPHICS_CARD
    HEADSET
    HEADSET_STAND
    KEYBOARD
    KEYPAD
    LED_CONTROLLER
    LED_MATRIX
    LED_STRIPE
    MAINBOARD
    MONITOR
    MOUSE
    MOUSEPAD
    NONE
    SPEAKER
    UNKNOWN
}

enum SortEnumType {
    ASC
    DESC
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar UUID

input BooleanOperationFilterInput {
    eq: Boolean
    neq: Boolean
}

input CategoryFilterInput {
    and: [CategoryFilterInput!]
    entryType: NullableOfEntryTypeOperationFilterInput
    icon: StringOperationFilterInput
    id: LongOperationFilterInput
    name: StringOperationFilterInput
    or: [CategoryFilterInput!]
}

input CategorySortInput {
    entryType: SortEnumType
    icon: SortEnumType
    id: SortEnumType
    name: SortEnumType
}

input CreateEntryInput {
    categories: [Long!]!
    defaultEntryInfo: DefaultEntryInfoInput
    description: String!
    entryType: EntryType!
    name: String!
    summary: String!
    tags: [String!]!
}

input CreateLayoutInfoInput {
    deviceProvider: UUID!
    deviceType: RGBDeviceType!
    entryId: Long!
    logicalLayout: String
    model: String!
    physicalLayout: KeyboardLayoutType
    vendor: String!
}

input DateTimeOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime]
    nlt: DateTime
    nlte: DateTime
}

input DefaultEntryInfoFilterInput {
    and: [DefaultEntryInfoFilterInput!]
    entryId: LongOperationFilterInput
    isDeviceProvider: BooleanOperationFilterInput
    isEssential: BooleanOperationFilterInput
    or: [DefaultEntryInfoFilterInput!]
}

input DefaultEntryInfoInput {
    isDeviceProvider: Boolean!
    isEssential: Boolean!
}

input DefaultEntryInfoSortInput {
    entryId: SortEnumType
    isDeviceProvider: SortEnumType
    isEssential: SortEnumType
}

input EntryFilterInput {
    and: [EntryFilterInput!]
    author: StringOperationFilterInput
    authorId: UuidOperationFilterInput
    categories: ListFilterInputTypeOfCategoryFilterInput
    createdAt: DateTimeOperationFilterInput
    defaultEntryInfo: DefaultEntryInfoFilterInput
    dependantReleases: ListFilterInputTypeOfReleaseFilterInput
    description: StringOperationFilterInput
    downloads: LongOperationFilterInput
    entryType: EntryTypeOperationFilterInput
    icon: ImageFilterInput
    iconId: UuidOperationFilterInput
    id: LongOperationFilterInput
    images: ListFilterInputTypeOfImageFilterInput
    isOfficial: BooleanOperationFilterInput
    latestRelease: ReleaseFilterInput
    latestReleaseId: LongOperationFilterInput
    layoutInfo: ListFilterInputTypeOfLayoutInfoFilterInput
    name: StringOperationFilterInput
    or: [EntryFilterInput!]
    pluginInfo: PluginInfoFilterInput
    releases: ListFilterInputTypeOfReleaseFilterInput
    summary: StringOperationFilterInput
    tags: ListFilterInputTypeOfTagFilterInput
}

input EntrySortInput {
    author: SortEnumType
    authorId: SortEnumType
    createdAt: SortEnumType
    defaultEntryInfo: DefaultEntryInfoSortInput
    description: SortEnumType
    downloads: SortEnumType
    entryType: SortEnumType
    icon: ImageSortInput
    iconId: SortEnumType
    id: SortEnumType
    isOfficial: SortEnumType
    latestRelease: ReleaseSortInput
    latestReleaseId: SortEnumType
    name: SortEnumType
    pluginInfo: PluginInfoSortInput
    summary: SortEnumType
}

input EntryTypeOperationFilterInput {
    eq: EntryType
    in: [EntryType!]
    neq: EntryType
    nin: [EntryType!]
}

input ImageFilterInput {
    and: [ImageFilterInput!]
    description: StringOperationFilterInput
    entry: EntryFilterInput
    entryId: LongOperationFilterInput
    height: IntOperationFilterInput
    id: UuidOperationFilterInput
    mimeType: StringOperationFilterInput
    name: StringOperationFilterInput
    or: [ImageFilterInput!]
    size: LongOperationFilterInput
    width: IntOperationFilterInput
}

input ImageSortInput {
    description: SortEnumType
    entry: EntrySortInput
    entryId: SortEnumType
    height: SortEnumType
    id: SortEnumType
    mimeType: SortEnumType
    name: SortEnumType
    size: SortEnumType
    width: SortEnumType
}

input IntOperationFilterInput {
    eq: Int
    gt: Int
    gte: Int
    in: [Int]
    lt: Int
    lte: Int
    neq: Int
    ngt: Int
    ngte: Int
    nin: [Int]
    nlt: Int
    nlte: Int
}

input LayoutInfoFilterInput {
    and: [LayoutInfoFilterInput!]
    deviceProvider: UuidOperationFilterInput
    deviceType: RGBDeviceTypeOperationFilterInput
    entry: EntryFilterInput
    entryId: LongOperationFilterInput
    id: LongOperationFilterInput
    logicalLayout: StringOperationFilterInput
    model: StringOperationFilterInput
    or: [LayoutInfoFilterInput!]
    physicalLayout: NullableOfKeyboardLayoutTypeOperationFilterInput
    vendor: StringOperationFilterInput
}

input LayoutInfoInput {
    deviceProvider: UUID!
    deviceType: RGBDeviceType!
    logicalLayout: String
    model: String!
    physicalLayout: KeyboardLayoutType
    vendor: String!
}

input ListFilterInputTypeOfCategoryFilterInput {
    all: CategoryFilterInput
    any: Boolean
    none: CategoryFilterInput
    some: CategoryFilterInput
}

input ListFilterInputTypeOfEntryFilterInput {
    all: EntryFilterInput
    any: Boolean
    none: EntryFilterInput
    some: EntryFilterInput
}

input ListFilterInputTypeOfImageFilterInput {
    all: ImageFilterInput
    any: Boolean
    none: ImageFilterInput
    some: ImageFilterInput
}

input ListFilterInputTypeOfLayoutInfoFilterInput {
    all: LayoutInfoFilterInput
    any: Boolean
    none: LayoutInfoFilterInput
    some: LayoutInfoFilterInput
}

input ListFilterInputTypeOfReleaseFilterInput {
    all: ReleaseFilterInput
    any: Boolean
    none: ReleaseFilterInput
    some: ReleaseFilterInput
}

input ListFilterInputTypeOfTagFilterInput {
    all: TagFilterInput
    any: Boolean
    none: TagFilterInput
    some: TagFilterInput
}

input LongOperationFilterInput {
    eq: Long
    gt: Long
    gte: Long
    in: [Long]
    lt: Long
    lte: Long
    neq: Long
    ngt: Long
    ngte: Long
    nin: [Long]
    nlt: Long
    nlte: Long
}

input NullableOfEntryTypeOperationFilterInput {
    eq: EntryType
    in: [EntryType]
    neq: EntryType
    nin: [EntryType]
}

input NullableOfKeyboardLayoutTypeOperationFilterInput {
    eq: KeyboardLayoutType
    in: [KeyboardLayoutType]
    neq: KeyboardLayoutType
    nin: [KeyboardLayoutType]
}

input PluginInfoFilterInput {
    and: [PluginInfoFilterInput!]
    entry: EntryFilterInput
    entryId: LongOperationFilterInput
    helpPage: StringOperationFilterInput
    or: [PluginInfoFilterInput!]
    pluginGuid: UuidOperationFilterInput
    repository: StringOperationFilterInput
    requiresAdmin: BooleanOperationFilterInput
    supportsLinux: BooleanOperationFilterInput
    supportsOSX: BooleanOperationFilterInput
    supportsWindows: BooleanOperationFilterInput
    website: StringOperationFilterInput
}

input PluginInfoSortInput {
    entry: EntrySortInput
    entryId: SortEnumType
    helpPage: SortEnumType
    pluginGuid: SortEnumType
    repository: SortEnumType
    requiresAdmin: SortEnumType
    supportsLinux: SortEnumType
    supportsOSX: SortEnumType
    supportsWindows: SortEnumType
    website: SortEnumType
}

input RGBDeviceTypeOperationFilterInput {
    eq: RGBDeviceType
    in: [RGBDeviceType!]
    neq: RGBDeviceType
    nin: [RGBDeviceType!]
}

input ReleaseFilterInput {
    and: [ReleaseFilterInput!]
    changelog: StringOperationFilterInput
    createdAt: DateTimeOperationFilterInput
    dependencies: ListFilterInputTypeOfEntryFilterInput
    downloadSize: LongOperationFilterInput
    downloads: LongOperationFilterInput
    entry: EntryFilterInput
    entryId: LongOperationFilterInput
    id: LongOperationFilterInput
    md5Hash: StringOperationFilterInput
    minimumVersion: StringOperationFilterInput
    or: [ReleaseFilterInput!]
    version: StringOperationFilterInput
}

input ReleaseSortInput {
    changelog: SortEnumType
    createdAt: SortEnumType
    downloadSize: SortEnumType
    downloads: SortEnumType
    entry: EntrySortInput
    entryId: SortEnumType
    id: SortEnumType
    md5Hash: SortEnumType
    minimumVersion: SortEnumType
    version: SortEnumType
}

input SetLayoutInfoInput {
    entryId: Long!
    layoutInfo: [LayoutInfoInput!]!
}

input StringOperationFilterInput {
    and: [StringOperationFilterInput!]
    contains: String
    endsWith: String
    eq: String
    in: [String]
    ncontains: String
    nendsWith: String
    neq: String
    nin: [String]
    nstartsWith: String
    or: [StringOperationFilterInput!]
    startsWith: String
}

input TagFilterInput {
    and: [TagFilterInput!]
    id: LongOperationFilterInput
    name: StringOperationFilterInput
    or: [TagFilterInput!]
}

input UpdateEntryImageInput {
    description: String
    id: UUID!
    name: String!
}

input UpdateEntryInput {
    categories: [Long!]!
    defaultEntryInfo: DefaultEntryInfoInput
    description: String!
    id: Long!
    name: String!
    summary: String!
    tags: [String!]!
}

input UpdateReleaseInput {
    changelog: String
    id: Long!
}

input UuidOperationFilterInput {
    eq: UUID
    gt: UUID
    gte: UUID
    in: [UUID]
    lt: UUID
    lte: UUID
    neq: UUID
    ngt: UUID
    ngte: UUID
    nin: [UUID]
    nlt: UUID
    nlte: UUID
}
